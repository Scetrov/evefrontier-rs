# Data Model: Heat Mechanics

**Feature**: Heat Mechanics Integration  
**Phase**: 1 (Design & Contracts)  
**Date**: 2026-01-02

## Overview

This document defines the data structures for heat mechanics in EVE Frontier route planning. Heat
data follows the same architectural pattern as fuel projections: per-hop data embedded in
`RouteStep`, route-level aggregates in `RouteSummary`.

---

## Entities

### HeatProjection

**Purpose**: Per-hop heat data attached to individual route steps.

**Fields**:

| Field                     | Type             | Validation                   | Description                                                                            |
| ------------------------- | ---------------- | ---------------------------- | -------------------------------------------------------------------------------------- |
| `hop_heat`                | `f64`            | `>= 0.0`, `is_finite()`      | Heat generated by this specific hop (units)                                            |
| `cumulative_heat`         | `f64`            | `>= hop_heat`, `is_finite()` | Total accumulated heat up to this point (units)                                        |
| `warning`                 | `Option<String>` | -                            | Warning message if threshold exceeded (e.g., "Approaching heat limit")                 |
| `wait_time_seconds`       | `Option<f64>`    | `>= 0.0` if present          | Time to wait at this step to cool enough to perform the next jump (seconds)            |
| `cooled_cumulative_heat`  | `Option<f64>`    | `>= 0.0`, `is_finite()`      | Cumulative heat after waiting (if wait_time_seconds present)                           |
| `can_proceed`             | `bool`           | -                            | `true` if the hop can proceed after optional waiting, `false` if infeasible (critical) |

**Relationships**:

- Embedded in `RouteStep::heat: Option<HeatProjection>`
- First step (origin) has `heat: None`
- Gate transitions have `hop_heat = 0.0`, but include cumulative data

**Invariants**:

- `cumulative_heat >= hop_heat` (heat accumulates)
- `warning.is_some()` when the instantaneous temperature for a hop
    (`min_external_temp + hop_heat`) is >= `HEAT_OVERHEATED` or `HEAT_CRITICAL`.

**Cooling Model (proposal)**:

- When `attach_heat()` encounters a jump that would push `cumulative_heat + hop_heat` above the
    error threshold, it may compute a wait time using the system's `min_external_temp` and an
    explicit dissipation-rate source (not derived from per-ship CSV fields):

```rust
// Cooling efficiency factor (0..1) derived from external temperature
cooling_efficiency = clamp((MAX_TEMP - min_external_temp) / MAX_TEMP, 0.0, 1.0)
// Effective dissipation per second (if a dissipation model is introduced, the rate should come
// from an explicit source or global policy rather than an implicit per-ship CSV field)
dissipation_per_second = dissipation_rate_source * cooling_efficiency
// Required reduction in heat units to be at or below target (e.g., error threshold or safe threshold)
required_reduction = (cumulative_heat + hop_heat) - allowed_cumulative_after_wait
wait_seconds = required_reduction / dissipation_per_second
```

- `allowed_cumulative_after_wait` is typically the lesser of `max_heat_tolerance` (to avoid
  critical) or the warning threshold depending on policy.
- If `dissipation_per_second` == 0 (no cooling possible at that system), or `wait_seconds` is
  unreasonably large, mark `can_proceed = false` and include an explanatory warning.

**Notes**: The canonical dataset does **not** provide per-ship `max_heat_tolerance` or
`heat_dissipation_rate`. Cooling/dissipation models are considered future work and, if
implemented, will derive dissipation from environment (`min_external_temp`) and global policies
rather than per-ship tolerances. The model below is intentionally simple to keep tests stable and
the CLI deterministic when presenting wait times to users.

**Example**:

```rust
HeatProjection {
    hop_heat: 88.96,
    cumulative_heat: 88.96,
    // No label when instantaneous temperature is below HEAT_OVERHEATED
    warning: None,
    wait_time_seconds: Some(120.0),
    cooled_cumulative_heat: Some(60.0),
    can_proceed: true,
}
```

---

### HeatSummary

**Purpose**: Route-level heat aggregate displayed in summary footer.

**Fields**:

| Field           | Type          | Validation              | Description                                              |
| --------------- | ------------- | ----------------------- | -------------------------------------------------------- |
| `total`         | `f64`         | `>= 0.0`, `is_finite()` | Total heat generated across entire route (units)         |
| *No per-ship tolerance is stored.* Heat warnings are based on canonical absolute thresholds: `HEAT_OVERHEATED`, `HEAT_CRITICAL` |
| `warnings`      | `Vec<String>` | -                       | Aggregate warnings (label strings: `" OVERHEATED "` or `" CRITICAL "`) |

**Relationships**:

- Embedded in `RouteSummary::heat: Option<HeatSummary>`
- Present only when ship data provided to route planning

**Invariants**:

- `warnings` contains `" OVERHEATED "` when the route includes an instantaneous hop temperature
    >= `HEAT_OVERHEATED`
- `warnings` contains `" CRITICAL "` when the route includes an instantaneous hop temperature
    >= `HEAT_CRITICAL`

**Example**:

```rust
HeatSummary {
    total: 377.08,
    // Note: per-ship max_tolerance removed; use canonical HEAT_* thresholds instead
    percentage: 37.7,
    warnings: vec![],
}
```

**Example with warning**:

```rust
HeatSummary {
    total: 820.0,
    max_tolerance: 1000.0,
    percentage: 82.0,
    warnings: vec!["Heat exceeds safe threshold (75%)".to_string()],
}
```

---

### HeatConfig

**Purpose**: Configuration for heat calculations (passed to `calculate_jump_heat()`).

**Fields**:

| Field                  | Type   | Validation             | Description                                |
| ---------------------- | ------ | ---------------------- | ------------------------------------------ |
| `dynamic_mass`         | `bool` | -                      | Whether to recalculate mass after each hop |

**Relationships**:

- Passed to `RouteSummary::attach_heat()` alongside `ShipAttributes` and `ShipLoadout`
- Not serialized in output (internal calculation detail)

**Invariants**:

- `dynamic_mass` mirrors fuel calculation mode for consistency

**Calibration**:

The calibration constant is fixed to `1e-7` and is not exposed as a configurable field in
`HeatConfig` or via API requests. Implementations MUST use the fixed constant so that heat
projections remain stable and reproducible.

**Default**:

```rust
impl Default for HeatConfig {
    fn default() -> Self {
        Self { dynamic_mass: false }
    }
}
```

**Example**:

```rust
let config = HeatConfig {
    dynamic_mass: true,  // Recalculate mass per-hop
};
```

---

## State Transitions

### Heat Accumulation State Machine

```text
┌─────────────┐
│   Initial   │
│  heat = 0   │
└──────┬──────┘
       │ Start route
       v
┌─────────────────┐
│   Per-Hop       │
│  Accumulation   │──┐
└──────┬──────────┘  │
       │             │ For each step:
       │             │ - Gate: heat += 0
       │             │ - Jump: heat += hop_heat
       │             │
       │<────────────┘
       v
┌─────────────────┐
│   Check         │
│   Thresholds    │
└──────┬──────────┘
       │
       ├─→ heat < 75% tolerance ──→ No warning
       │
    ├─→ instantaneous_temp >= `HEAT_OVERHEATED` ──→ Warning: `" OVERHEATED "`
    │
    └─→ instantaneous_temp >= `HEAT_CRITICAL` ───→ Error: `" CRITICAL "`
```

**State Variables**:

- `cumulative_heat`: Current accumulated heat (starts at 0.0)
- `warning_threshold`: `HEAT_OVERHEATED`
- `error_threshold`: `HEAT_CRITICAL`

**Transitions**:

1. **Initial → Per-Hop**: Route planning begins, first step has `heat: None`
2. **Per-Hop**: For each subsequent step:
   - Gate: `cumulative_heat += 0.0` (no change)
   - Jump: `cumulative_heat += calculate_jump_heat(...)`
3. **Check Thresholds**: After each hop:
   - If `cumulative_heat > warning_threshold`: Add warning to step
   - If `cumulative_heat > error_threshold`: Add error to summary

**Immutability**: Heat cannot decrease (no dissipation in this implementation). Once accumulated,
heat persists for the entire route.

---

## Validation Rules

### Input Validation

All numeric inputs validated before calculations:

```rust
fn validate_heat_inputs(
    total_mass_kg: f64,
    distance_ly: f64,
    hull_mass_kg: f64,
    calibration: f64,
) -> Result<()> {
    if !total_mass_kg.is_finite() || total_mass_kg <= 0.0 {
        return Err(Error::ShipDataValidation {
            message: "total_mass_kg must be finite and positive".to_string(),
        });
    }
    if !distance_ly.is_finite() || distance_ly < 0.0 {
        return Err(Error::ShipDataValidation {
            message: "distance_ly must be finite and non-negative".to_string(),
        });
    }
    if !hull_mass_kg.is_finite() || hull_mass_kg <= 0.0 {
        return Err(Error::ShipDataValidation {
            message: "hull_mass_kg must be finite and positive".to_string(),
        });
    }
    if !calibration.is_finite() || calibration <= 0.0 {
        return Err(Error::ShipDataValidation {
            message: "calibration_constant must be finite and positive".to_string(),
        });
    }
    Ok(())
}
```

### Output Validation

Calculated heat values validated before storage:

```rust
fn validate_heat_output(heat: f64) -> Result<()> {
    if !heat.is_finite() {
        return Err(Error::ShipDataValidation {
            message: "calculated heat must be finite".to_string(),
        });
    }
    if heat < 0.0 {
        return Err(Error::ShipDataValidation {
            message: "calculated heat must be non-negative".to_string(),
        });
    }
    Ok(())
}
```

---

## Serialization Schema

### Serde Attributes

```rust
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct HeatProjection {
    pub hop_heat: f64,
    pub cumulative_heat: f64,
    pub warning: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub warning: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub wait_time_seconds: Option<f64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cooled_cumulative_heat: Option<f64>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct HeatSummary {
    pub total: f64,
    // No per-ship tolerance stored. See HEAT_OVERHEATED/HEAT_CRITICAL for threshold values.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub warnings: Vec<String>,
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub struct HeatConfig {
    pub calibration_constant: f64,
    pub dynamic_mass: bool,
}
```

**Note**: `HeatConfig` not serialized (internal use only).

---

## Example Data Flow

### Reflex Route: Nod → Brana (3 hops)

**Ship Data**:

- Hull mass: 10,000,000 kg
- Fuel load: 1,750 units (1,750 kg)
- Cargo: 633,006 kg
- Total mass: 12,383,006 kg
- Max heat tolerance: 1,000 units

**Route Steps** (static mass mode):

#### Step 0: Nod (Origin)

```rust
RouteStep {
    ```
    ┌─────────────┐
    │   Initial   │
    │  heat = 0   │
    └──────┬──────┘
        │ Start route
        v
    ┌─────────────────┐
    │   Per-Hop       │
    │  Accumulation   │──┐
    └──────┬──────────┘  │
        │             │ For each step:
        │             │ - Gate: heat += 0
        │             │ - Jump: heat += hop_heat
        │<────────────┘
        v
    ┌─────────────────┐
    │   Check         │
    │   Thresholds    │
    └──────┬──────────┘
        │
        ├─→ heat < HEAT_OVERHEATED ──→ No warning (Nominal)
        │
        ├─→ HEAT_OVERHEATED ≤ heat < HEAT_CRITICAL ──→ Warning: "Overheated"
        │
        └─→ heat ≥ HEAT_CRITICAL ──────────→ Error / Infeasible: "Critical heat reached"
    ```
#### Step 2: G:3OA0 (Jump 38.26 ly)

```rust
RouteStep {
    index: 2,
    id: 30000004,
    name: Some("G:3OA0"),
    distance: Some(38.26),
    method: Some("jump"),
    heat: Some(HeatProjection {
        hop_heat: 179.73,
        cumulative_heat: 268.69,
        warning: null,
        warning: None,
    }),
}
```

#### Step 3: Brana (Jump 23.09 ly)

```rust
RouteStep {
    index: 3,
    id: 30000002,
    name: Some("Brana"),
    distance: Some(23.09),
    method: Some("jump"),
    heat: Some(HeatProjection {
        hop_heat: 108.39,
        cumulative_heat: 377.08,
        warning: null,
        warning: None,
    }),
}
```

**Route Summary**:

```rust
RouteSummary {
    // ... other fields ...
    heat: Some(HeatSummary {
        total: 377.08,
        // max_tolerance omitted (not provided by canonical dataset)
        percentage: 37.7,
        warnings: vec![],
    }),
}
```

---

## Integration Points

### RouteStep Extension

```rust
// In crates/evefrontier-lib/src/output.rs

#[derive(Debug, Clone, Serialize, PartialEq)]
pub struct RouteStep {
    // ... existing fields ...

    /// Heat projection for this hop (present when ship data supplied).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub heat: Option<HeatProjection>,
}
```

### RouteSummary Extension

```rust
// In crates/evefrontier-lib/src/output.rs

#[derive(Debug, Clone, Serialize, PartialEq)]
pub struct RouteSummary {
    // ... existing fields ...

    /// Aggregated heat summary when ship data is provided.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub heat: Option<HeatSummary>,
}
```

### Attachment Method

```rust
impl RouteSummary {
    /// Attach heat projections to each hop using the supplied ship/loadout/config.
    pub fn attach_heat(
        &mut self,
        ship: &ShipAttributes,
        loadout: &ShipLoadout,
        config: &HeatConfig,
    ) -> Result<()> {
        // Implementation mirrors attach_fuel() pattern
        // See ship.rs for calculate_jump_heat() function
    }
}
```

---

## References

- `specs/020-heat/research.md` — Formula validation and test cases
- `crates/evefrontier-lib/src/ship.rs` — Ship data structures
- `crates/evefrontier-lib/src/output.rs` — Route output structures
- `docs/HEAT_MECHANICS.md` — Community-validated heat formula
